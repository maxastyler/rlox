* RLOX
Implementation of lox in Rust from [[https://craftinginterpreters.com/][crafting interpreters]], but with a different syntax.

** Parsing

Everything in the language is an expression - returns a value.

Built in pipe operator

Structs, not classes

Traits system like rust

Function declaration is done:

fn (Optional name) (args) {block of stuff}

Functions:

fn (x, y) {x .+ x; y .+ y}

fn something (x, y) {x .+ x}

If given a name, then that name is bound in the current block to the function.

Functions have tail recursion - the current stack frame is reused when the surrounding function
is called again in tail position.

A function of no arguments can be called like f!

Struct:

More complicated...

Grammar:

order of precedence:

literal
function
block
parenthesised
no argument call
infix
function call

a block introduces a new scope, a parenthesised block doesn't

#+begin_src
symbol = identifier without spaces
literal = number | string | boolean | symbol
function = 'fn' [symbol] ['('symbol*')'] block
parenthesised = '(' [expression, ';'] ')'
block = '{' [expression, ';']+ '}'
l1 = block | parenthesised | function | literal
no_arg_call = l1'!'
l2 = l1 | no_arg_call
infix = l2 '.' l2 l2*
l3 = l2 | infix
call = l3 l3+
l4 = l3 | call
assignment = 'let' symbol '=' expression
expression = l4 | assignment
#+end_src

let x 2
let y 2
let z 4

** Structure of the VM
Every function call is a chunk, which contains the bytecode, and constants

** What's the problem with the structure?

The function to create the values wants them to live longer

** What expressions are there, and what are the bytecodes they produce?

- Symbol
  Gets the value associated to the symbol.
  Op codes: [FindInStack(position of symbol in stack)]
  Effect: +1
- Ignored
  This wraps an expression, to ignore its value
  Op codes: [Pop]
  Effect: -1
- Literal
  Represents a literal value
  Op codes: [Constant(position in constant table for chunk)]
  Effect: +1
- Function
  Represents a function. If there is a symbol, assigns the symbol to the function
  in the current scope.
  Op codes: [CreateClosure AddUpvalue(upvalue index) EndClosure (Assign to symbol) Push Closure]
  Effect: +1
- Assignment
  Assignment of a value to a name
  Op codes: [Assign(index of previous) | Create()]
  Effect: +1
- Block
  Run a block of expressions, then discard all variables declared inside block
  Op codes [(inside expressions) (pop all variables) (push result of last expression in block)]
  Effect: +1
- Parenthesised
  Parenthesise an expression
  Op codes [expressions]
  This is just a syntactic thing...
  Effect: +1
- Call
  Call a closure
  Call op code creates a new stack frame, assuming the parameters and closure have been pushed
  onto the stack
  Op codes: [Call (do expressions) push result]
  Effect: +1
- Cond
  Do a cond block
  Have all the different branches, each one pointing at the next thing
  Result is the individual result of each one
  Effect: +1

